
<!-- This document was automatically generated with bibtex2html 1.97
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     bibtex2html-1.97/bibtex2html -d -r -nodoc -nf videos videos -nf reviews reviews -nf full-bibliography "full bibliography" -nf bibliography bibliography -nf code-v "code (.v)" -nf code-html "code (.html)" -nf code-agda "code (.agda)" -nf artifact-zip "artifact (.zip)" -nf code-github "project (<img src='media/GitHub-Mark/PNG/GitHub-Mark-32px.png' alt='GitHub' title='GitHub' style='height:1em; vertical-align:text-bottom' />)" -nf original-url "original conference submission (.pdf)" -nf presentation-annotated-pptx "presentation (.pptx, annotated with notes)" -nf presentation-pptx "presentation (.pptx)" -nf url-pptx .pptx -nf presentation-pdf "presentation (.pdf)" -nf published-url publication -nf published-url-springer "Springer publication" --title "L&ouml;b's Theorem: A functional pearl of dependently typed quining: List of References" -o papers/lob-paper/lob-bibliography papers/lob-paper/lob-bibliography-filtered.bib  -->

<h1>L&ouml;b's Theorem: A functional pearl of dependently typed quining: List of References</h1>
<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="brown2016breaking">1</a>]
</td>
<td class="bibtexitem">
Matt Brown and Jens Palsberg.
 Breaking through the normalization barrier: A self-interpreter for
  f-omega.
 In <em>Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT
  Symposium on Principles of Programming Languages</em>, pages 5-17. ACM, 2016.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#brown2016breaking">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/2837614.2837623">DOI</a>&nbsp;| 
<a href="http://compilers.cs.ucla.edu/popl16/popl16-full.pdf">.pdf</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="nott31169">2</a>]
</td>
<td class="bibtexitem">
Thorsten Altenkirch and Ambrus Kaposi.
 Type theory in type theory using quotient inductive types.
 In <em>POPL '16 The 43rd Annual ACM SIGPLAN-SIGACT Symposium on
  Principles of Programming Languages</em>. ACM, 2016.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#nott31169">bib</a>&nbsp;| 
<a href="http://eprints.nottingham.ac.uk/31169/">http</a>&nbsp;]
<blockquote><font size="-1">
We present an internal formalisation of a type heory with dependent types in Type Theory using a special case of higher inductive types from Homotopy Type Theory which we call quotient inductive types (QITs). Our formalisation of type theory avoids referring to preterms or a typability relation but defines directly well typed objects by an inductive definition. We use the elimination principle to define the set-theoretic and logical predicate interpretation. The work has been formalized using the Agda system extended with QITs using postulates.
</font></blockquote>
<p><blockquote><font size="-1">
Keywords: Higher Inductive Types, Homotopy Type Theory, Logical Relations, Metaprogramming, Agda
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="paulson2015mechanised">3</a>]
</td>
<td class="bibtexitem">
Lawrence&nbsp;C Paulson.
 A mechanised proof of G&ouml;del's incompleteness theorems using
  Nominal Isabelle.
 <em>Journal of Automated Reasoning</em>, 55(1):1-37, 2015.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#paulson2015mechanised">bib</a>&nbsp;| 
<a href="https://www.cl.cam.ac.uk/~lp15/papers/Formath/Goedel-ar.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
An Isabelle/HOL formalisation of G&ouml;del's two incompleteness theorems is presented. The work follows &#x15a;wierczkowski's detailed proof of the theorems using hereditarily finite (HF) set theory (Dissertationes Mathematicae 422, 1-58, 2003). Avoiding the usual arithmetical encodings of syntax eliminates the necessity to formalise elementary number theory within an embedded logical calculus. The Isabelle formalisation uses two separate treatments of variable binding: the nominal package (Logical Methods in Computer Science 8(2:14), 1-35, 2012) is shown to scale to a development of this complexity, while de Bruijn indices (Indagationes Mathematicae 34, 381-392, 1972) turn out to be ideal for coding syntax. Critical details of the Isabelle proof are described, in particular gaps and errors found in the literature.
</font></blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Yudkowsky2014">4</a>]
</td>
<td class="bibtexitem">
Brienne Yudkowsky.
 Lob's theorem cured my social anxiety, February 2014.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#Yudkowsky2014">bib</a>&nbsp;| 
<a href="http://agentyduck.blogspot.com/2014/02/lobs-theorem-cured-my-social-anxiety.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="BaraszChristianoFallensteinEtAl2014">5</a>]
</td>
<td class="bibtexitem">
Mihaly Barasz, Paul Christiano, Benja Fallenstein, Marcello Herreshoff, Patrick
  LaVictoire, and Eliezer Yudkowsky.
 Robust cooperation in the prisoner's dilemma: Program equilibrium via
  provability logic.
 <em>ArXiv e-prints</em>, January 2014.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#BaraszChristianoFallensteinEtAl2014">bib</a>&nbsp;| 
<a href="http://arxiv.org/abs/1401.5577">arXiv</a>&nbsp;| 
<a href="http://arxiv.org/pdf/1401.5577v1.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
We consider the one-shot Prisoner's Dilemma between algorithms with read-access to one anothers' source codes, and we use the modal logic of provability to build agents that can achieve mutual cooperation in a manner that is robust, in that cooperation does not require exact equality of the agents' source code, and unexploitable, meaning that such an agent never cooperates when its opponent defects. We construct a general framework for such "modal agents", and study their properties.
</font></blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="geuvers2014church">6</a>]
</td>
<td class="bibtexitem">
Herman Geuvers.
 The Church-Scott representation of inductive and coinductive
  data, 2014.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#geuvers2014church">bib</a>&nbsp;| 
<a href="http://www.cs.ru.nl/~herman/PUBS/ChurchScottDataTypes.pdf">.pdf</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="SimmonsToninho2012">7</a>]
</td>
<td class="bibtexitem">
Robert&nbsp;J. Simmons and Bernardo Toninho.
 Constructive provability logic.
 <em>CoRR</em>, abs/1205.6402, May 2012.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#SimmonsToninho2012">bib</a>&nbsp;| 
<a href="http://arxiv.org/abs/1205.6402">arXiv</a>&nbsp;| 
<a href="http://arxiv.org/abs/1205.6402">http</a>&nbsp;]
<blockquote><font size="-1">
We present constructive provability logic, an intuitionstic modal logic that validates the L&ouml;b rule of G&ouml;del and L&ouml;b's provability logic by permitting logical reflection over provability. Two distinct variants of this logic, CPL and CPL*, are presented in natural deduction and sequent calculus forms which are then shown to be equivalent. In addition, we discuss the use of constructive provability logic to justify stratified negation in logic programming within an intuitionstic and structural proof theory.
</font></blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Kiselyov2012">8</a>]
</td>
<td class="bibtexitem">
Oleg Kiselyov.
 Beyond church encoding: Boehm-berarducci isomorphism of algebraic
  data types and polymorphic lambda-terms, April 2012.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#Kiselyov2012">bib</a>&nbsp;| 
<a href="http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="mcbride2010outrageous">9</a>]
</td>
<td class="bibtexitem">
Conor McBride.
 Outrageous but meaningful coincidences: Dependent type-safe syntax
  and evaluation.
 In <em>Proceedings of the 6th ACM SIGPLAN workshop on Generic
  programming</em>, pages 1-12. ACM, 2010.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#mcbride2010outrageous">bib</a>&nbsp;| 
<a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/DepRep/DepRep.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Tagless interpreters for well-typed terms in some object language are a standard example of the power and benefit of precise indexing in types, whether with dependent types, or generalized algebraic datatypes. The key is to reflect object language types as indices (however they may be constituted) for the term datatype in the host language, so that host type coincidence ensures object type coincidence. Whilst this technique is widespread for simply typed object languages, dependent types have proved a tougher nut with nontrivial computation in type equality. In their type-safe representations, Danielsson [2006] and Chapman [2009] succeed in capturing the equality rules, but at the cost of representing equality derivations explicitly within terms. This article delivers a type-safe representation for a dependently typed object language, dubbed KIPLING, whose computational type equality just appropriates that of its host, Agda. The Kipling interpreter example is not merely <em>de rigeur</em>- it is key to the construction. At the heart of the technique is that key component of generic programming, the <em>universe</em>.
</font></blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Chapman200921">10</a>]
</td>
<td class="bibtexitem">
James Chapman.
 Type theory should eat itself.
 <em>Electronic Notes in Theoretical Computer Science</em>, 228:21-36,
  2009.
 Proceedings of the International Workshop on Logical Frameworks and
  Metalanguages: Theory and Practice (LFMTP 2008).
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#Chapman200921">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1016/j.entcs.2008.12.114">DOI</a>&nbsp;| 
<a href="http://www.sciencedirect.com/science/article/pii/S157106610800577X">http</a>&nbsp;]
<blockquote><font size="-1">
In this paper I present a partial formalisation of a normaliser for type theory in Agda [Ulf Norell. Agda 2, 2007. http://www.cs.chalmers.se/&nbsp;ulfn/]; extending previous work on big-step normalisation [Thorsten Altenkirch and James Chapman. Big-Step Normalisation. Journal of Functional Programming, 2008. Special Issue on Mathematically Structured Functional Programming. To appear, Thorsten Altenkirch and James Chapman. Tait in one big step. In Workshop on Mathematically Structured Functional Programming, {MSFP} 2006, Kuressaare, Estonia, July 2, 2006, electronic Workshop in Computing (eWiC), Kuressaare, Estonia, 2006. The British Computer Society (BCS)]. The normaliser in written as an environment machine. Only the computational behaviour of the normaliser is presented omitting details of termination. 
</font></blockquote>
<p><blockquote><font size="-1">
Keywords: big-step normalisation
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="cartoon-lobs-theorem">11</a>]
</td>
<td class="bibtexitem">
Eliezer Yudkowsky.
 (the cartoon guide to) L&ouml;b's theorem, 2008.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#cartoon-lobs-theorem">bib</a>&nbsp;| 
<a href="http://www.yudkowsky.net/rational/lobs-theorem">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Altenkirch:2007:OE:1292597.1292608">12</a>]
</td>
<td class="bibtexitem">
Thorsten Altenkirch, Conor McBride, and Wouter Swierstra.
 Observational equality, now!
 In <em>Proceedings of the 2007 Workshop on Programming Languages
  Meets Program Verification</em>, PLPV '07, pages 57-68, New York, NY, USA, 2007.
  ACM.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#Altenkirch:2007:OE:1292597.1292608">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/1292597.1292608">DOI</a>&nbsp;| 
<a href="http://www.cs.nott.ac.uk/~psztxa/publ/obseqnow.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
This paper has something new and positive to say about propositional equality in programming and proof systems based on the Curry-Howard correspondence between propositions and types. We have found a way to present a propositional equality type
<p><ul>
<br> &bull; which is substitutive, allowing us to reason by replacing equal for equal in propositions;
<br> &bull; which reflects the observable behaviour of values rather than their construction: in particular, we <br> &bull; have extensionality- functions are equal if they take equal inputs to equal outputs;
<br> &bull; which retains strong normalisation, decidable typechecking and canonicity-the property that closed normal forms inhabiting datatypes have canonical constructors;
<br> &bull; which allows inductive data structures to be expressed in terms of a standard characterisation of well-founded trees;
<br> &bull; which is presented syntactically-you can implement it directly, and we are doing so this approach stands at the core of Epigram 2;
<br> &bull; which you can play with now: we have simulated our system by a shallow embedding in Agda 2, shipping as part of the standard examples package for that system [21].
</ul>
Until now, it has always been necessary to sacrifice some of these aspects. The closest attempt in the literature is Altenkirch's construction of a setoid-model for a system with canonicity and extensionality on top of an intensional type theory with proof-irrelevant propositions [4]. Our new proposal simplifies Altenkirch's construction by adopting McBride's heterogeneous approach to equality [19].
</font></blockquote>
<p><blockquote><font size="-1">
Keywords: equality, type theory
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="appel2007very">13</a>]
</td>
<td class="bibtexitem">
Andrew&nbsp;W Appel, Paul-Andr&eacute; Mellies, Christopher&nbsp;D Richards, and
  J&eacute;r&ocirc;me Vouillon.
 A very modal model of a modern, major, general type system.
 <em>ACM SIGPLAN Notices</em>, 42(1):109-122, 2007.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#appel2007very">bib</a>&nbsp;| 
<a href="https://www.cs.princeton.edu/~appel/papers/modalmodel.pdf">.pdf</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="danielsson2006formalisation">14</a>]
</td>
<td class="bibtexitem">
Nils&nbsp;Anders Danielsson.
 A formalisation of a dependently typed language as an
  inductive-recursive family.
 In Thorsten Altenkirch and Conor McBride, editors, <em>Types for
  Proofs and Programs</em>, volume 4502 of <em>Lecture Notes in Computer Science</em>,
  chapter A Formalisation of a Dependently Typed Language as an
  Inductive-Recursive Family, pages 93-109. Springer Berlin Heidelberg,
  Berlin, Heidelberg, 2007.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#danielsson2006formalisation">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/978-3-540-74464-1_7">DOI</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/978-3-540-74464-1_7">http</a>&nbsp;]
<blockquote><font size="-1">
It is demonstrated how a dependently typed lambda calculus (a logical framework) can be formalised inside a language with inductive- recursive families. The formalisation does not use raw terms; the well- typed terms are defined directly. It is hence impossible to create ill-typed terms.<p>
As an example of programming with strong invariants, and to show that the formalisation is usable, normalisation is proved. Moreover, this proof seems to be the first formal account of normalisation by evaluation for a dependently typed language.
</font></blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="piponi-from-l-theorem-to-spreadsheet">15</a>]
</td>
<td class="bibtexitem">
Dan Piponi.
 From l&ouml;b's theorem to spreadsheet evaluation, November 2006.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#piponi-from-l-theorem-to-spreadsheet">bib</a>&nbsp;| 
<a href="http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="altenkirch2006towards">16</a>]
</td>
<td class="bibtexitem">
Thorsten Altenkirch and Conor McBride.
 Towards observational type theory.
 <em>Manuscript, available online</em>, 2006.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#altenkirch2006towards">bib</a>&nbsp;| 
<a href="http://strictlypositive.org/ott.pdf">.pdf</a>&nbsp;]
<blockquote><font size="-1">
Observational Type Theory (OTT) combines benefi-
cial aspects of Intensional and Extensional Type Theory
(ITT/ETT). It separates definitional equality, decidable as in
ITT, and a substitutive propositional equality, capturing extensional
equality of functions, as in ETT. Moreover, canonicity
holds: any closed term is definitionally reducible to a
canonical value.<p>
Building on previous work by each author, this article
reports substantial progress in the form of a simplified theory
with a straightforward syntactic presentation, which we
have implemented.<p>
As well as simplifying reasoning about functions, OTT
offers potential foundational benefits, e.g. it gives rise to a
closed type theory encoding inductive datatypes.
</font></blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DBLP:journals/corr/abs-cs-0505034">17</a>]
</td>
<td class="bibtexitem">
Russell O'Connor.
 Essential incompleteness of arithmetic verified by Coq.
 <em>CoRR</em>, abs/cs/0505034, 2005.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#DBLP:journals/corr/abs-cs-0505034">bib</a>&nbsp;| 
<a href="http://arxiv.org/abs/cs/0505034">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Davies:2001:MAS:382780.382785">18</a>]
</td>
<td class="bibtexitem">
Rowan Davies and Frank Pfenning.
 A modal analysis of staged computation.
 <em>J. ACM</em>, 48(3):555-604, May 2001.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#Davies:2001:MAS:382780.382785">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/382780.382785">DOI</a>&nbsp;| 
<a href="http://doi.acm.org/10.1145/382780.382785">http</a>&nbsp;]
<blockquote><font size="-1">
Keywords: binding times, run-time code generation, staged computation
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DBLP:conf/ershov/Mogensen01">19</a>]
</td>
<td class="bibtexitem">
Torben&nbsp;&AElig;. Mogensen.
 An investigation of compact and efficient number representations in
  the pure lambda calculus.
 In <em>Perspectives of System Informatics, 4th International Andrei
  Ershov Memorial Conference, PSI 2001, Akademgorodok, Novosibirsk, Russia,
  July 2-6, 2001, Revised Papers</em>, pages 205-213, 2001.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#DBLP:conf/ershov/Mogensen01">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/3-540-45575-2_20">DOI</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/3-540-45575-2_20">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="loopsnoop">20</a>]
</td>
<td class="bibtexitem">
Geoffrey&nbsp;K. Pullum.
 Scooping the loop snooper, October 2000.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#loopsnoop">bib</a>&nbsp;| 
<a href="http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="shankar1997metamathematics">21</a>]
</td>
<td class="bibtexitem">
Natarajan Shankar.
 <em>Metamathematics, Machines and G&ouml;del's Proof</em>.
 Cambridge University Press, 1997.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#shankar1997metamathematics">bib</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="constable1995using">22</a>]
</td>
<td class="bibtexitem">
Robert&nbsp;L Constable.
 Using reflection to explain and enhance type theory.
 In <em>Proof and Computation</em>, pages 109-144. Springer, 1995.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#constable1995using">bib</a>&nbsp;| 
<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.23.5290&rep=rep1&type=pdf">http</a>&nbsp;]
<blockquote><font size="-1">
The five lectures at Marktoberdorf on which these notes are based were about the architecture of problem solving environments which use theorem provers. Experience with these systems over the past two decades has shown that the prover must be extensible, yet it must be kept. We examine a way to safely add new decision procedures to the Nuprl prover. It relies on a reflection mechanism and is applicable to any tactic-oriented prover with sufficient reflection. The lectures explain reflection in the setting of constructive type theory, the core logic of Nuprl.
</font></blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="PFENNING1991137">23</a>]
</td>
<td class="bibtexitem">
Frank Pfenning and Peter Lee.
 Metacircularity in the polymorphic &lambda;-calculus.
 <em>Theoretical Computer Science</em>, 89(1):137-159, 1991.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#PFENNING1991137">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1016/0304-3975(90)90109-U">DOI</a>&nbsp;| 
<a href="http://www.sciencedirect.com/science/article/pii/030439759090109U">http</a>&nbsp;]
<blockquote><font size="-1">
We consider the question of whether a useful notion of metacircularity exists for the polymorphic &lambda;-calculus. Even though complete metacircularity seems to be impossible, we obtain a close approximation to a metacircular interpreter. We begin by presenting an encoding for the Girard-Reynolds second-order polymorphic &lambda;-calculus in the third-order polymorphic &lambda;-calculus. The encoding makes use of representations in which abstractions are represented by abstractions, thus eliminating the need for the explicit representation of environments. We then extend this construction to encompass all of the &omega;-order polymorphic &lambda;-calculus (F<sub>&omega;</sub>). The representation has the property that evaluation is definable, and furthermore that only well-typed terms can be represented and thus type inference does not have to be explicitly defined. Unfortunately, this metacircularity result seems to fall short of providing a useful framework for typed metaprogramming. We speculate on the reasons for this failure and the prospects for overcoming it in the future. In addition, we briefly describe our efforts in designing a practical programming language based on F<sub>&omega;</sub>.
</font></blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Shankar:1986:PM:913294">24</a>]
</td>
<td class="bibtexitem">
Natarajan Shankar.
 <em>Proof-checking Metamathematics (Theorem-proving)</em>.
 PhD thesis, The University of Texas at Austin, 1986.
 AAI8717580.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#Shankar:1986:PM:913294">bib</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Berarducci1985">25</a>]
</td>
<td class="bibtexitem">
Alessandro Berarducci and Corrado B&ouml;hm.
 Automatic synthesis of typed &lambda;-programs on term algebras.
 <em>Theoretical Computer Science</em>, 39(820076097):135-154, 1985.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#Berarducci1985">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1016/0304-3975(85)90135-5">DOI</a>&nbsp;| 
<a href="http://www.sciencedirect.com/science/article/pii/0304397585901355">http</a>&nbsp;]
<blockquote><font size="-1">
The notion of iteratively defined functions from and to heterogeneous term algebras is introduced as the solution of a finite set of equations of a special shape. Such a notion has remarkable consequences: (1) Choosing the second-order typed lambda- calculus (Lambsa for short) as a programming language enables one to represent algebra elements and iterative functions by automatic uniform synthesis paradigms, using neither conditional nor recursive constructs. (2) A completeness theorem for Lambda-terms with type of degree at most two and a companion corollary for Lambda-programs have been proved. (3) A new congruence relation for the last-mentioned Lambda-terms which is stronger than Lambda-convertibility is introduced and proved to have the meaning of a Lambda-program equivalence. Moreover, an extension of the paradigms to the synthesis of functions of higher complexity is considered and exemplified. All the concepts are explained and motivated by examples over integers, list- and tree-structures.
</font></blockquote>
<p>
</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="hofstadter1980godel">26</a>]
</td>
<td class="bibtexitem">
Douglas&nbsp;R. Hofstadter.
 <em>G&ouml;del, Escher, Bach: An Eternal Golden Braid</em>.
 Vintage, 1979.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#hofstadter1980godel">bib</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="scott1963system">27</a>]
</td>
<td class="bibtexitem">
Dana Scott.
 A system of functional abstraction.
 Unpublished manuscript, 1963.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#scott1963system">bib</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="kleene1952introduction">28</a>]
</td>
<td class="bibtexitem">
Stephen&nbsp;Cole Kleene.
 <em>Introduction to Metamathematics</em>.
 Wolters-Noordhoff, 1952.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#kleene1952introduction">bib</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="church1940formulation">29</a>]
</td>
<td class="bibtexitem">
Alonzo Church.
 A formulation of the simple theory of types.
 <em>The Journal of Symbolic Logic</em>, 5(2):56-68, 1940.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#church1940formulation">bib</a>&nbsp;| 
<a href="http://www.jstor.org/stable/2266170">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="tarski1936undefinability">30</a>]
</td>
<td class="bibtexitem">
Alfred Tarski.
 Der Wahrheitsbegriff in den formalisierten Sprachen.
 <em>Studia Philosophica</em>, 1:261-405, 1936.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#tarski1936undefinability">bib</a>&nbsp;| 
<a href="http://www.w-k-essler.de/pdfs/Tarski.pdf">.pdf</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="godel1931formal">31</a>]
</td>
<td class="bibtexitem">
Kurt G&ouml;del.
 &Uuml;ber formal unentscheidbare S&auml;tze der Principia
  Mathematica und verwandter Systeme I.
 <em>Monatshefte f&uuml;r mathematik und physik</em>, 38(1):173-198,
  1931.
[&nbsp;<a href="papers/lob-paper/lob-bibliography_bib.html#godel1931formal">bib</a>&nbsp;| 
<a href="http://www.w-k-essler.de/pdfs/goedel.pdf">.pdf</a>&nbsp;]

</td>
</tr>
</table><hr><p><em>This file was generated by
<a href="http://www.lri.fr/~filliatr/bibtex2html/">bibtex2html</a> 1.97.</em></p>
