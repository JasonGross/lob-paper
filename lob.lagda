 \documentclass[preprint%,nonatbib%
]{sigplanconf}

 \usepackage{cmap,mmap}
 \usepackage{accsupp}

 % The following packages are needed because unicode
 % is translated (using the next set of packages) to
 % latex commands. You may need more packages if you
 % use more unicode characters:

 % This handles the translation of unicode to latex:

 \newcommand{\unicodesub}[1]{\ensuremath{{}_{\text{#1}}}}

 \usepackage[autogenerated]{ucs}
 \usepackage[utf8x]{inputenc}
 % \usepackage{autofe}

 \usepackage{agda}

 \usepackage{amssymb}
 \usepackage{amsmath}
 \usepackage{hyperref}
 \usepackage{xcolor}
 \usepackage{minted}
 \usepackage{upquote}
 \usepackage{stmaryrd}
 % \usepackage{bbm}
 \usepackage[english]{babel}

 % disable minted red error boxes on syntax error
 \makeatletter
 \expandafter\def\csname PYGdefault@tok@err\endcsname{\def\PYGdefault@bc##1{{\strut ##1}}}
 \makeatother

 % Some characters that are not automatically defined
 % (you figure out by the latex compilation errors you get),
 % and you need to define:

 \newcommand*{\ucopyable}[2]{%
   \BeginAccSupp{%
     method=hex,%
     unicode,%
     ActualText=#1%
   }%
   #2%
   \EndAccSupp{}%
 }

 \DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
 \DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
 \DeclareUnicodeCharacter{8990}{\ensuremath{\llcorner}}
 \DeclareUnicodeCharacter{8991}{\ensuremath{\lrcorner}}
 %\DeclareUnicodeCharacter{9633}{\ensuremath{\square}}
 \DeclareUnicodeCharacter{931}{\ucopyable{03A3}{\ensuremath{\Sigma}}}
 \DeclareUnicodeCharacter{915}{\ucopyable{0393}{\ensuremath{\Gamma}}}
 \DeclareUnicodeCharacter{928}{\ucopyable{03A0}{\ensuremath{\Pi}}}
 %\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
 \DeclareUnicodeCharacter{9659}{\ensuremath{\triangleright}}
 \DeclareUnicodeCharacter{1255}{\"o}
 %\DeclareUnicodeCharacter{7488}{\ensuremath{{}^T}}
 %\DeclareUnicodeCharacter{7511}{\ensuremath{{}^t}}
 %\DeclareUnicodeCharacter{7580}{\ensuremath{{}^c}}
 %\DeclareUnicodeCharacter{8336}{\ensuremath{{}_a}}
 %\DeclareUnicodeCharacter{8348}{\ensuremath{{}_t}}
 \DeclareUnicodeCharacter{8216}{\text{\textquoteleft}}
 \DeclareUnicodeCharacter{8217}{\text{\textquoteright}}

 % Add more as you need them (shouldn’t happen often).

 %\undef\bibfont
 %\usepackage[style=abbrvnat,authoryear,square,natbib=true]{biblatex}
 %\bibpunct{(}{)}{;}{a}{}{,}
 %\let \cite = \citep

 %\addbibresource{lob.bib}

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{ICFP '16}{September 19--21, 2016, Nara, Japan}
\copyrightyear{2016}
%\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
%\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{L\"ob's Theorem}
\subtitle{A functional pearl of dependently typed quining}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

 \AgdaHide{
  \begin{code}
module lob where
  \end{code}
}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
\terms
Agda, Lob, quine, self-reference

\keywords
Agda, Lob, quine, self-reference

\begin{abstract}
This is the text of the abstract.
\end{abstract}

\begin{quotation}
\noindent \textit{If P's answer is `Bad!', Q will suddenly stop. \\
But otherwise, Q will go back to the top, \\
and start off again, looping endlessly back, \\
till the universe dies and turns frozen and black.}
\end{quotation}
\begin{flushright}
Excerpt from \emph{Scooping the Loop Snooper} \cite{loopsnoop})
\end{flushright}

\section*{TODO}
  - cite Using Reflection to Explain and Enhance Type Theory?


\section{Introduction}
 L\"ob's thereom has a variety of applications, from proving incompleteness of a logical theory as a trivial corrolary, to acting as a no-go theorem for a large class of self-interpreters (\todo{mention F$_{\text{omega}}$?}), from allowing robust cooperation in the Prisoner's Dilemma with Source Code~\cite{}, to curing social anxiety~\cite{}.

 ``What is L\"ob's theorem, this versatile tool with wonderous applications?'' you may ask.

 Consider the sentence ``if this sentence is true, then you, dear reader, are the most awesome person in the world.''  Suppose that this sentence is true.  Then you, dear reader are the most awesome person in the world.  Since this is exactly what the sentence asserts, the sentence is true, and you, dear reader, are the most awesome person in the world.  For those more comfortable with symbolic logic, we can let $X$ be the statement ``you, dear reader, are the most awesome person in the world'', and we can let $A$ be the statement ``if this sentence is true, then $X$''.  Since we have that $A$ and $A → B$ are the same, if we assume $A$, we are also assuming $A → B$, and hence we have $B$, and since assuming $A$ yields $B$, we have that $A → B$.  What went wrong?\footnote{Those unfamiliar with conditionals should note that the ``if \ldots\space then \ldots'' we use here is the logical ``if'', where ``if false then $X$'' is always true, and not the counterfactual ``if''.}

 It can be made quite clear that something is wrong; the more common form of this sentence is used to prove the existence of Santa Claus to logical children: considering the sentence ``if this sentence is true, then Santa Claus exists'', we can prove that Santa Claus exists.  By the same logic, though, we can prove that Santa Claus does not exist by considering the sentence ``if this sentence is true, then Santa Claus does not exist.''  Whether you consider it absurd that Santa Claus exist, or absurd that Santa Claus not exist, surely you will consider it absurd that Santa Claus both exist and not exist.  This is known as Curry's paradox.

 Have you figured out what went wrong?

 The sentence that we have been considering is not a valid mathematical sentence.  Ask yourself what makes it invalid, while we consider a similar sentence that is actually valid.

 Now consider the sentence``if this sentence is provable, then you, dear reader, are the most awesome person in the world.''  Fix a particular formalization of provability (for example, Peano Arithmetic, or Martin--L\"of Type Theory).  To prove that this sentence is true, suppose that it is provable.  We must now show that you, dear reader, are the most awesome person in the world.  \emph{If provability implies truth}, then the sentence is true, and then you, dear reader, are the most awesome person in the world.  Thus, if we can assume that provability implies truth, then we can prove that the sentence is true.  This, in a nutshell, is L\"ob's theorem: to prove $X$, it suffices to prove that $X$ is true whenever $X$ is provable.  Symbolically, this is
$$□ (□ X -> X) → □ X$$
where $□ X$ means ``$X$ is provable'' (in our fixed formalization of provability).

 Let us now return to the question we posed above: what went wrong with our original sentence?  The answer is that self-reference with truth is impossible, and the clearest way I know to argue for this is via the Curry--Howard Isomorphism; in a particular technical sense, the problem is that self-reference with truth fails to terminate.

 The Curry--Howard Isomorphism establishes an equivalence between types and propositions, between (well-typed, terminating, functional) programs and proofs.  See \autoref{table:curry-howard} for some examples.  Now we ask: what corresponds to a formalization of provability?  If a proof of P is a terminating functional program which is well-typed at the type corresponding to P, and to assert that P is provable is to assert that the type corresponding to P is inhabited, then an encoding of a proof is an encoding of a program.  Although mathematicians typically use G\"odel codes to encode propositions and proofs, a more natural choice of encoding programs will be abstract syntax trees.  In particular, a valid syntactic proof of a given (syntactic) proposition corresponds to a well-typed syntax tree for an inhabitant of the corresponding syntactic type.

  \begin{table}
  \begin{center}
  \begin{tabular}{ccc}
  Logic & Programming & Set Theory \\ \hline
  Proposition & Type & Set of Proofs \\
  Proof & Program & Element \\
  Implication (→) & Function (→) & Function  \\
  Conjunction (∧) & Pairing (,) & Cartesian Product (×)  \\
  Disjunction (∨) & Sum (+) & Disjoint Union (⊔) \\
  Gӧdel codes & ASTs & ---
  \end{tabular}
  \end{center}
  \caption{The Curry-Howard isomorphism between mathematical logic and functional programming} \label{table:curry-howard}
  \end{table}

 Unless otherwise specified, we will henceforth consider only well-typed, terminating programs; when we say ``program'', the adjectives ``well-typed'' and ``terminating'' are implied.

 Before diving into L\"ob's theorem in detail, we'll first visit a standard paradigm for formalizing the syntax of dependent type theory. (\todo{Move this?})

\section{Quines}
 What is the computational equivalent of the sentence ``If this sentence is provable, then $X$''?  It will be something of the form ``??? → $X$''.  As a warm-up, let's look at a Python program that returns a string representation of this type.

 To do this, we need a program that outputs its own source code.  There are three genuinely distinct solutions, the first of which is degenerate, and the second of which is cheeky (or sassy?).  These ``cheating'' solutions are:
 \begin{itemize}
   \item The empty program, which outputs nothing.
   \item The program \mintinline{python}|print(open(__file__, 'r').read())|, which relies on the Python interpreter to get the source code of the program.
 \end{itemize}

 Now we develop the standard solution.  At a first gloss, it looks like:
\begin{minted}[mathescape,
%               numbersep=5pt,
               gobble=2,
%               frame=lines,
%               framesep=2mm%
]{python}
  (lambda T: '(' + T + ') -> X') "???"
\end{minted}

 Now we need to replace \mintinline{python}|"???"| with the entirety of this program code.  We use Python's string escaping function (\mintinline{python}|repr|) and replacement syntax (\mintinline{python}|("foo %s bar" % "baz")| becomes \mintinline{python}|"foo baz bar"|):

\begin{minted}[gobble=2]{python}
  (lambda T: '(' + T % repr(T) + ') → X')
   ("(lambda T: '(' + T %% repr(T) + ') → X')\n (%s)")
\end{minted}
 This is a slight modification on the standard way of programming a quine, a program that outputs its own source-code.

 Suppose we have a function □ that takes in a string representation of a type, and returns the type of syntax trees of programs producing that type.  Then our L\"obian sentence would look something like (if → were valid notation for function types in Python)
\begin{minted}[gobble=1]{python}
 (lambda T: □ (T % repr(T)) → X)
  ("(lambda T: □ (T %% repr(T)) → X)\n (%s)")
\end{minted}
 Now, finally, we can see what goes wrong when we consider using ``if this sentence is true'' rather than ``if this sentence is provable''.  Provability corresponds to syntax trees for programs; truth corresponds to execution of the program itself.  Our pseudo-Python thus becomes
\begin{minted}[gobble=1]{python}
 (lambda T: eval(T % repr(T)) → X)
  ("(lambda T: eval(T %% repr(T)) → X)\n (%s)")
\end{minted}

 This code never terminates!  So, in a quite literal sense, the issue with our original sentence was that, if we tried to phrase it, we'd never finish.

 Note well that the type (□ X → X) is a type that takes syntax trees and evaluates them; it is the type of an interpreter.  (\todo{maybe move this sentence?})

\section{Abstract Syntax Trees for Dependent Type Theory}

  The idea of formalizing a type of syntax trees which only permits well-typed programs is common in the literature.  (\todo{citations})  For example, here is a very simple (and incomplete) formalization with $\Pi$, a unit type (⊤), an empty type (⊥), and lambdas.  (\todo{FIXME: What's the right level of simplicity?})  \todo{mention convention of ‘’?}

  We will use some standard data type declarations, which are provided for completeness in \autoref{sec:common}.
 \AgdaHide{
  \begin{code}
open import common public
  \end{code}
}
\AgdaHide{
  \begin{code}
module dependent-type-theory where
  \end{code}
}

\noindent
\begin{code}
 mutual
  infixl 2 _▻_

  data Context : Set where
   ε : Context
   _▻_ : (Γ : Context) → Type Γ → Context

  data Type : Context → Set where
   ‘⊤’ : ∀ {Γ} → Type Γ
   ‘⊥’ : ∀ {Γ} → Type Γ
   ‘Π’ : ∀ {Γ} → (A : Type Γ) → Type (Γ ▻ A) → Type Γ

  data Term : {Γ : Context} → Type Γ  → Set where
   ‘tt’ : ∀ {Γ} → Term {Γ} ‘⊤’
   ‘λ’ : ∀ {Γ A B} → Term {Γ ▻ A} B → Term (‘Π’ A B)
 \end{code}

  An easy way to check consistency of a syntactic theory which is weaker than the theory of the ambient proof assistant is to define an interpretation function, also commonly known as an unquoter, or a denotation function, from the syntax into the universe of types.  Here is an example of such a function:

\begin{code}
 mutual
  ⟦_⟧ᶜ : Context → Set
  ⟦ ε ⟧ᶜ = ⊤
  ⟦ Γ ▻ T ⟧ᶜ = Σ ⟦ Γ ⟧ᶜ ⟦ T ⟧ᵀ

  ⟦_⟧ᵀ : ∀ {Γ} → Type Γ → ⟦ Γ ⟧ᶜ → Set
  ⟦ ‘⊤’ ⟧ᵀ ⟦Γ⟧ = ⊤
  ⟦ ‘⊥’ ⟧ᵀ ⟦Γ⟧ = ⊥
  ⟦ ‘Π’ A B ⟧ᵀ ⟦Γ⟧ = (x : ⟦ A ⟧ᵀ ⟦Γ⟧) → ⟦ B ⟧ᵀ (⟦Γ⟧ , x)

  ⟦_⟧ᵗ : ∀ {Γ T} → Term {Γ} T → (⟦Γ⟧ : ⟦ Γ ⟧ᶜ) → ⟦ T ⟧ᵀ ⟦Γ⟧
  ⟦ ‘tt’ ⟧ᵗ ⟦Γ⟧ = tt
  ⟦ ‘λ’ f ⟧ᵗ ⟦Γ⟧ x = ⟦ f ⟧ᵗ (⟦Γ⟧ , x)
\end{code}

  \todo{Maybe mention something about the denotation function being ``local'', i.e., not needing to do anything but the top-level case-analysis?}

\section{This Paper}
 In this paper, we make extensive use of this trick for validating models.  We formalize the simplest syntax that supports L\"ob's theorem and prove it sound relative to Agda in 12 lines of code; the understanding is that this syntax could be extended to support basically anything you might want.  We then present an extended version of this solution, which supports enough operations that we can prove our syntax sound (consistent), incomplete, and nonempty.  In a hundred lines of code, we prove L\"ob's theorem under the assumption that we are given a quine; this is basically the well-typed functional version of the program that uses \mintinline{python}|open(__file__, 'r').read()|.  Finally, we sketch our implementation of L\"ob's theorem (code in an appendix) based on the assumption only that we can add a level of quotation to our syntax tree; this is the equivalent of letting the compiler implement \mintinline{python}|repr|, rather than implementing it ourselves.  We close with an application to the prisoner's dilemma, as well as some discussion about avenues for removing the hard-coded \mintinline{python}|repr|. \todo{Ensure that this ordering is accurate}

\section{Prior Work}
  \todo{Use of L\"ob's theorem in program logic as an induction principle? (TODO)}

  \todo{Brief mention of Lob's theorem in Haskell / elsewhere / ? (TODO)}

\section{Trivial Encoding}
\AgdaHide{
  \begin{code}
module trivial-encoding where
 infixr 1 _‘→’_
  \end{code}
}

 We begin with a language that supports almost nothing other than Lӧb's theorem.  We use \mintinline{Agda}|□ T| to denote the type of \mintinline{Agda}|Term|s of whose syntactic type is \mintinline{Agda}|T|.  We use \mintinline{Agda}|‘□’ T| to denote the syntactic type corresponding to the type of (syntactic) terms whose syntactic type is \mintinline{Agda}|T| \todo{This is probably unclear.  Maybe mention repr?}.

\begin{code}
 data Type : Set where
   _‘→’_ : Type → Type → Type
   ‘□’ : Type → Type

 data □ : Type → Set where
   Lӧb : ∀ {X} → □ (‘□’ X ‘→’ X) → □ X
\end{code}
The only term supported by our term language is Lӧb's theorem.  We can prove this language consistent relative to Agda with an interpreter:

\begin{code}
 ⟦_⟧ᵀ : Type → Set
 ⟦ A ‘→’ B ⟧ᵀ = ⟦ A ⟧ᵀ → ⟦ B ⟧ᵀ
 ⟦ ‘□’ T ⟧ᵀ   = □ T

 ⟦_⟧ᵗ : ∀ {T : Type} → □ T → ⟦ T ⟧ᵀ
 ⟦ Lӧb □‘X’→X ⟧ᵗ = ⟦ □‘X’→X ⟧ᵗ (Lӧb □‘X’→X)
\end{code}
To interpret Lӧb's theorem applied to the syntax for a compiler $f$ (\mintinline{Agda}|□‘X’→X| in the code above), we interpret $f$, and then apply this interpretation to the constructor \mintinline{Agda}|Lӧb| applied to $f$.

Finally, we tie it all together:

\begin{code}
 lӧb : ∀ {‘X’} → □ (‘□’ ‘X’ ‘→’ ‘X’) → ⟦ ‘X’ ⟧ᵀ
 lӧb f = ⟦ Lӧb f ⟧ᵗ
\end{code}

This code is deceptively short, with all of the interesting work happening in the interpretation of \mintinline{Agda}|Lӧb|.

What have we actually proven, here?  It may seem as though we've Certainly \emph{not} that self-interpreters


\section{Encoding with Soundness, Incompleteness, and Non-Emptyness}

\AgdaHide{
  \begin{code}
module sound-incomplete-nonempty where
 infixr 1 _‘→’_
  \end{code}
}

\begin{code}
 data Type : Set where
  _‘→’_ : Type → Type → Type
  ‘□’ : Type → Type
  ‘⊤’ : Type
  ‘⊥’ : Type

 data □ : Type → Set where
  Lӧb : ∀ {X} → □ (‘□’ X ‘→’ X) → □ X
  ‘tt’ : □ ‘⊤’

 ⟦_⟧ᵀ : Type → Set
 ⟦ A ‘→’ B ⟧ᵀ = ⟦ A ⟧ᵀ → ⟦ B ⟧ᵀ
 ⟦ ‘□’ T ⟧ᵀ   = □ T
 ⟦ ‘⊤’ ⟧ᵀ     = ⊤
 ⟦ ‘⊥’ ⟧ᵀ     = ⊥

 ⟦_⟧ᵗ : ∀ {T : Type} → □ T → ⟦ T ⟧ᵀ
 ⟦ Lӧb □‘X’→X ⟧ᵗ = ⟦ □‘X’→X ⟧ᵗ (Lӧb □‘X’→X)
 ⟦ ‘tt’ ⟧ᵗ = tt

 ¬_ : Set → Set
 ¬ T = T → ⊥

 ‘¬’_ : Type → Type
 ‘¬’ T = T ‘→’ ‘⊥’

 lӧb : ∀ {‘X’} → □ (‘□’ ‘X’ ‘→’ ‘X’) → ⟦ ‘X’ ⟧ᵀ
 lӧb f = ⟦ Lӧb f ⟧ᵗ

 incompleteness : ¬ □ (‘¬’ (‘□’ ‘⊥’))
 incompleteness = lӧb

 soundness : ¬ □ ‘⊥’
 soundness x = ⟦ x ⟧ᵗ

 non-emptyness : □ ‘⊤’
 non-emptyness = ‘tt’

 no-interpreters : ¬ (∀ {‘X’} → □ (‘□’ ‘X’ ‘→’ ‘X’))
 no-interpreters interp = lӧb (interp {‘⊥’})
\end{code}

\section{Encoding with Quines}
\begin{code}
module lob-by-quines where
 infixl 2 _▻_
 infixl 3 _‘’_
 infixr 1 _‘→’_
 infixl 3 _‘’ₐ_
 infixl 3 _w‘‘’’ₐ_
 infixr 2 _‘∘’_

 mutual
  data Context : Set where
   ε : Context
   _▻_ : (Γ : Context) → Type Γ → Context

  data Type : Context → Set where
   W : ∀ {Γ A} → Type Γ → Type (Γ ▻ A)
   W₁ : ∀ {Γ A B} → Type (Γ ▻ B) → Type (Γ ▻ A ▻ (W B))
   _‘’_ : ∀ {Γ A} → Type (Γ ▻ A) → Term A → Type Γ
   ‘Typeε’ : ∀ {Γ} → Type Γ
   ‘□’ : ∀ {Γ} → Type (Γ ▻ ‘Typeε’)
   _‘→’_ : ∀ {Γ} → Type Γ → Type Γ → Type Γ
   Quine : Type (ε ▻ ‘Typeε’) → Type ε
   ‘⊤’ : ∀ {Γ} → Type Γ
   ‘⊥’ : ∀ {Γ} → Type Γ

  data Term : {Γ : Context} → Type Γ → Set where
   ⌜_⌝ᵀ : ∀ {Γ} → Type ε → Term {Γ} ‘Typeε’
   ⌜_⌝ᵗ : ∀ {Γ T} → Term {ε} T → Term {Γ} (‘□’ ‘’ ⌜ T ⌝ᵀ)
   ‘⌜‘VAR₀’⌝ᵗ’ : ∀ {T}
     → Term {ε ▻ ‘□’ ‘’ ⌜ T ⌝ᵀ} (W (‘□’ ‘’ ⌜ ‘□’ ‘’ ⌜ T ⌝ᵀ ⌝ᵀ))
   ‘λ∙’ : ∀ {Γ A B} → Term {Γ ▻ A} (W B) → Term (A ‘→’ B)
   ‘VAR₀’ : ∀ {Γ T} → Term {Γ ▻ T} (W T)
   _‘’ₐ_ : ∀ {Γ A B}
    → Term {Γ} (A ‘→’ B)
    → Term {Γ} A
    → Term {Γ} B
   quine→ : ∀ {φ} → Term {ε} (Quine φ        ‘→’ φ ‘’ ⌜ Quine φ ⌝ᵀ)
   quine← : ∀ {φ} → Term {ε} (φ ‘’ ⌜ Quine φ ⌝ᵀ ‘→’ Quine φ)
   ‘tt’ : ∀ {Γ} → Term {Γ} ‘⊤’
   →SW₁SV→W : ∀ {Γ T X A B} {x : Term X}
     → Term {Γ} (T ‘→’ (W₁ A ‘’ ‘VAR₀’ ‘→’ W B) ‘’ x)
     → Term {Γ} (T ‘→’ A ‘’ x ‘→’ B)
   ←SW₁SV→W : ∀ {Γ T X A B} {x : Term X}
     → Term {Γ} ((W₁ A ‘’ ‘VAR₀’ ‘→’ W B) ‘’ x ‘→’ T)
     → Term {Γ} ((A ‘’ x ‘→’ B) ‘→’ T)
   w : ∀ {Γ A T} → Term {Γ} A → Term {Γ ▻ T} (W A)
   w→ : ∀ {Γ A B X}
    → Term {Γ} (A ‘→’ B)
    → Term {Γ ▻ X} (W A ‘→’ W B)
   _‘∘’_ : ∀ {Γ A B C}
    → Term {Γ} (B ‘→’ C)
    → Term {Γ} (A ‘→’ B)
    → Term {Γ} (A ‘→’ C)
   _w‘‘’’ₐ_ : ∀ {A B T}
    → Term {ε ▻ T} (W (‘□’ ‘’ ⌜ A ‘→’ B ⌝ᵀ))
    → Term {ε ▻ T} (W (‘□’ ‘’ ⌜ A ⌝ᵀ))
    → Term {ε ▻ T} (W (‘□’ ‘’ ⌜ B ⌝ᵀ))

 □ : Type ε → Set _
 □ = Term {ε}

 max-level : Level
 max-level = lzero   ---- also works for any higher level

 mutual
  ⟦_⟧ᶜ : (Γ : Context) → Set (lsuc max-level)
  ⟦ ε ⟧ᶜ  = ⊤
  ⟦ Γ ▻ T ⟧ᶜ = Σ ⟦ Γ ⟧ᶜ ⟦ T ⟧ᵀ

  ⟦_⟧ᵀ : ∀ {Γ} → Type Γ → ⟦ Γ ⟧ᶜ → Set max-level
  ⟦ W T ⟧ᵀ ⟦Γ⟧ = ⟦ T ⟧ᵀ (Σ.proj₁ ⟦Γ⟧)
  ⟦ W₁ T ⟧ᵀ ⟦Γ⟧ = ⟦ T ⟧ᵀ ((Σ.proj₁ (Σ.proj₁ ⟦Γ⟧)) , (Σ.proj₂ ⟦Γ⟧))
  ⟦ T ‘’ x ⟧ᵀ ⟦Γ⟧ = ⟦ T ⟧ᵀ (⟦Γ⟧ , ⟦ x ⟧ᵗ ⟦Γ⟧)
  ⟦ ‘Typeε’ ⟧ᵀ ⟦Γ⟧ = Lifted (Type ε)
  ⟦ ‘□’ ⟧ᵀ  ⟦Γ⟧ = Lifted (Term {ε} (lower (Σ.proj₂ ⟦Γ⟧)))
  ⟦ A ‘→’ B ⟧ᵀ ⟦Γ⟧ = ⟦ A ⟧ᵀ ⟦Γ⟧ → ⟦ B ⟧ᵀ ⟦Γ⟧
  ⟦ ‘⊤’ ⟧ᵀ ⟦Γ⟧ = ⊤
  ⟦ ‘⊥’ ⟧ᵀ ⟦Γ⟧ = ⊥
  ⟦ Quine φ ⟧ᵀ ⟦Γ⟧ = ⟦ φ ⟧ᵀ (⟦Γ⟧ , lift (Quine φ))

  ⟦_⟧ᵗ : ∀ {Γ T} → Term {Γ} T → (⟦Γ⟧ : ⟦ Γ ⟧ᶜ) → ⟦ T ⟧ᵀ ⟦Γ⟧
  ⟦ ⌜ x ⌝ᵀ ⟧ᵗ ⟦Γ⟧ = lift x
  ⟦ ⌜ x ⌝ᵗ ⟧ᵗ ⟦Γ⟧ = lift x
  ⟦ ‘⌜‘VAR₀’⌝ᵗ’ ⟧ᵗ ⟦Γ⟧ = lift ⌜ lower (Σ.proj₂ ⟦Γ⟧) ⌝ᵗ
  ⟦ f ‘’ₐ x ⟧ᵗ ⟦Γ⟧ = ⟦ f ⟧ᵗ ⟦Γ⟧ (⟦ x ⟧ᵗ ⟦Γ⟧)
  ⟦ ‘tt’ ⟧ᵗ  ⟦Γ⟧ = tt
  ⟦ quine→ ⟧ᵗ ⟦Γ⟧ x = x
  ⟦ quine← ⟧ᵗ ⟦Γ⟧ x = x
  ⟦ ‘λ∙’ f ⟧ᵗ ⟦Γ⟧ x = ⟦ f ⟧ᵗ (⟦Γ⟧ , x)
  ⟦ ‘VAR₀’ ⟧ᵗ ⟦Γ⟧ = Σ.proj₂ ⟦Γ⟧
  ⟦ ←SW₁SV→W f ⟧ᵗ = ⟦ f ⟧ᵗ
  ⟦ →SW₁SV→W f ⟧ᵗ = ⟦ f ⟧ᵗ
  ⟦ w x ⟧ᵗ ⟦Γ⟧ = ⟦ x ⟧ᵗ (Σ.proj₁ ⟦Γ⟧)
  ⟦ w→ f ⟧ᵗ ⟦Γ⟧ = ⟦ f ⟧ᵗ (Σ.proj₁ ⟦Γ⟧)
  ⟦ g ‘∘’ f ⟧ᵗ ⟦Γ⟧ x = ⟦ g ⟧ᵗ ⟦Γ⟧ (⟦ f ⟧ᵗ ⟦Γ⟧ x)
  ⟦ f w‘‘’’ₐ x ⟧ᵗ ⟦Γ⟧ = lift (lower (⟦ f ⟧ᵗ ⟦Γ⟧) ‘’ₐ lower (⟦ x ⟧ᵗ ⟦Γ⟧))

 module inner (‘X’ : Type ε)
              (‘f’ : Term {ε} (‘□’ ‘’ ⌜ ‘X’ ⌝ᵀ ‘→’ ‘X’))
        where
  ‘H’ : Type ε
  ‘H’ = Quine (W₁ ‘□’ ‘’ ‘VAR₀’ ‘→’ W ‘X’)

  ‘toH’ : □ ((‘□’ ‘’ ⌜ ‘H’ ⌝ᵀ ‘→’ ‘X’) ‘→’ ‘H’)
  ‘toH’ = ←SW₁SV→W quine←

  ‘fromH’ : □ (‘H’ ‘→’ (‘□’ ‘’ ⌜ ‘H’ ⌝ᵀ ‘→’ ‘X’))
  ‘fromH’ = →SW₁SV→W quine→

  ‘□‘H’→□‘X’’ : □ (‘□’ ‘’ ⌜ ‘H’ ⌝ᵀ ‘→’ ‘□’ ‘’ ⌜ ‘X’ ⌝ᵀ)
  ‘□‘H’→□‘X’’
    = ‘λ∙’ (w ⌜ ‘fromH’ ⌝ᵗ w‘‘’’ₐ ‘VAR₀’ w‘‘’’ₐ ‘⌜‘VAR₀’⌝ᵗ’)

  ‘h’ : Term ‘H’
  ‘h’ = ‘toH’ ‘’ₐ (‘f’ ‘∘’ ‘□‘H’→□‘X’’)

  Lӧb : □ ‘X’
  Lӧb = ‘fromH’ ‘’ₐ ‘h’ ‘’ₐ ⌜ ‘h’ ⌝ᵗ

 Lӧb : ∀ {X} → □ (‘□’ ‘’ ⌜ X ⌝ᵀ ‘→’ X) → □ X
 Lӧb {X} f = inner.Lӧb X f

 ⟦_⟧ : Type ε → Set _
 ⟦ T ⟧ = ⟦ T ⟧ᵀ tt

 ‘¬’_ : ∀ {Γ} → Type Γ → Type Γ
 ‘¬’ T = T ‘→’ ‘⊥’

 lӧb : ∀ {‘X’} → □ (‘□’ ‘’ ⌜ ‘X’ ⌝ᵀ ‘→’ ‘X’) → ⟦ ‘X’ ⟧
 lӧb f = ⟦_⟧ᵗ (Lӧb f) tt

 ¬_ : ∀ {ℓ m} → Set ℓ → Set (ℓ ⊔ m)
 ¬_ {ℓ} {m} T = T → ⊥ {m}

 incompleteness : ¬ □ (‘¬’ (‘□’ ‘’ ⌜ ‘⊥’ ⌝ᵀ))
 incompleteness = lӧb

 soundness : ¬ □ ‘⊥’
 soundness x = ⟦ x ⟧ᵗ tt

 non-emptyness : Σ (Type ε) (λ T → □ T)
 non-emptyness = ‘⊤’ , ‘tt’

\end{code}

\section{Digression: Application of Quining to The Prisoner's Dilemma}

  In this section, we use a slightly more enriched encoding of syntax; see \autoref{sec:prisoners-dilemma-lob-encoding} for details.

\AgdaHide{
  \begin{code}
module prisoners-dilemma where
 open import prisoners-dilemma-lob public
  \end{code}
}


\begin{code}
 open lob

 ---- a bot takes in the source code for itself,
 ---- for another bot, and spits out the assertion
 ---- that it cooperates with this bot
 ‘Bot’ : ∀ {Γ} → Type Γ
 ‘Bot’ {Γ}
   = Quine (W₁ ‘Term’ ‘’ ‘VAR₀’
            ‘→’ W₁ ‘Term’ ‘’ ‘VAR₀’
            ‘→’ W (‘Type’ Γ))

 _cooperates-with_ : □ ‘Bot’ → □ ‘Bot’ → Type ε
 b₁ cooperates-with b₂ = lower (⟦ b₁ ⟧ᵗ tt (lift b₁) (lift b₂))

 ‘eval-bot'’ : ∀ {Γ} → Term {Γ} (‘Bot’ ‘→’ (‘□’ ‘Bot’ ‘→’ ‘□’ ‘Bot’ ‘→’ ‘Type’ Γ))
 ‘eval-bot'’ = →SW₁SV→SW₁SV→W quine→

 ‘‘eval-bot'’’ : ∀ {Γ} → Term {Γ} (‘□’ ‘Bot’ ‘→’ ‘□’ ({- other -} ‘□’ ‘Bot’ ‘→’ ‘Type’ Γ))
 ‘‘eval-bot'’’ = ‘λ∙’ (w ⌜ ‘eval-bot'’ ⌝ᵗ w‘‘’’ₐ ‘VAR₀’ w‘‘’’ₐ ‘⌜‘VAR₀’⌝ᵗ’)

 ‘other-cooperates-with’ : ∀ {Γ} → Term {Γ ▻ ‘□’ ‘Bot’ ▻ W (‘□’ ‘Bot’)} (W (W (‘□’ ‘Bot’)) ‘→’ W (W (‘□’ (‘Type’ Γ))))
 ‘other-cooperates-with’ {Γ} = ‘eval-other'’ ‘∘’ w→ (w (w→ (w (‘λ∙’ ‘⌜‘VAR₀’⌝ᵗ’))))
   where
     ‘eval-other’ : Term {Γ ▻ ‘□’ ‘Bot’ ▻ W (‘□’ ‘Bot’)} (W (W (‘□’ (‘□’ ‘Bot’ ‘→’ ‘Type’ Γ))))
     ‘eval-other’ = w→ (w (w→ (w ‘‘eval-bot'’’))) ‘’ₐ ‘VAR₀’

     ‘eval-other'’ : Term (W (W (‘□’ (‘□’ ‘Bot’))) ‘→’ W (W (‘□’ (‘Type’ Γ))))
     ‘eval-other'’ = ww→ (w→ (w (w→ (w ‘‘’ₐ’))) ‘’ₐ ‘eval-other’)

 ‘self’ : ∀ {Γ} → Term {Γ ▻ ‘□’ ‘Bot’ ▻ W (‘□’ ‘Bot’)} (W (W (‘□’ ‘Bot’)))
 ‘self’ = w ‘VAR₀’

 ‘other’ : ∀ {Γ} → Term {Γ ▻ ‘□’ ‘Bot’ ▻ W (‘□’ ‘Bot’)} (W (W (‘□’ ‘Bot’)))
 ‘other’ = ‘VAR₀’

 make-bot : ∀ {Γ} → Term {Γ ▻ ‘□’ ‘Bot’ ▻ W (‘□’ ‘Bot’)} (W (W (‘Type’ Γ))) → Term {Γ} ‘Bot’
 make-bot t = ←SW₁SV→SW₁SV→W quine← ‘’ₐ ‘λ∙’ (→w (‘λ∙’ t))

 ww‘‘‘¬’’’_ : ∀ {Γ A B}
   → Term {Γ ▻ A ▻ B} (W (W (‘□’ (‘Type’ Γ))))
   → Term {Γ ▻ A ▻ B} (W (W (‘□’ (‘Type’ Γ))))
 ww‘‘‘¬’’’ T = T ww‘‘‘→’’’ w (w ⌜ ⌜ ‘⊥’ ⌝ ⌝ᵗ)

 ‘DefectBot’ : □ ‘Bot’
 ‘CooperateBot’ : □ ‘Bot’
 ‘FairBot’ : □ ‘Bot’
 ‘PrudentBot’ : □ ‘Bot’

 ‘DefectBot’ = make-bot (w (w ⌜ ‘⊥’ ⌝))
 ‘CooperateBot’ = make-bot (w (w ⌜ ‘⊤’ ⌝))
 ‘FairBot’ = make-bot (‘‘□’’ (‘other-cooperates-with’ ‘’ₐ ‘self’))
 ‘PrudentBot’ = make-bot (‘‘□’’ (φ₀ ww‘‘‘×’’’ (¬□⊥ ww‘‘‘→’’’ other-defects-against-DefectBot)))
   where
     φ₀ : ∀ {Γ} → Term {Γ ▻ ‘□’ ‘Bot’ ▻ W (‘□’ ‘Bot’)} (W (W (‘□’ (‘Type’ Γ))))
     φ₀ = ‘other-cooperates-with’ ‘’ₐ ‘self’

     other-defects-against-DefectBot : Term {_ ▻ ‘□’ ‘Bot’ ▻ W (‘□’ ‘Bot’)} (W (W (‘□’ (‘Type’ _))))
     other-defects-against-DefectBot = ww‘‘‘¬’’’ (‘other-cooperates-with’ ‘’ₐ w (w ⌜ ‘DefectBot’ ⌝ᵗ))

     ¬□⊥ : ∀ {Γ A B} → Term {Γ ▻ A ▻ B} (W (W (‘□’ (‘Type’ Γ))))
     ¬□⊥ = w (w ⌜ ⌜ ‘¬’ (‘□’ ‘⊥’) ⌝ ⌝ᵗ)

\end{code}

\section{Encoding with Add-Quote Function}
(appendix)
  - Discuss whiteboard phrasing of sentence with sigmas
    - It remains to show that we can construct
  - Discuss whiteboard phrasing of untyped sentence
    - Given:
      - X
      - □ = Term
      - f : □ 'X' -> X
      - define y : X
      - Suppose we have a type H ≅ Term ⌜ H → X ⌝, and we have
        - toH : Term ⌜ H → X ⌝ → H
        - fromH : H → Term ⌜ H → X ⌝
        - quote : H → Term ⌜ H ⌝
        -
      - Then we can define
      - \verb|y = (λ h : H. f (subst (quote h) h) (toH '\h : H. f (subst (quote h) h)')...|
\section{Removing add-quote and actually tying the knot (future work 1)}

- Bibliography
- Appendix
- Temporary outline section to be moved
  -
  - How do we construct the Curry--Howard analogue of the L\"obian sentence?  A quine is a program that outputs its own source code~\cite{}.  We will say that a \emph{type-theoretic quine} is a program that outputs its own (well-typed) abstract syntax tree.  Generalizing this slightly, we can consider programs that output an arbitrary function of their own syntax trees.
  - TODO: Examples of double quotation, single quotation, etc.
  - Given any function φ from doubly-quoted syntactic types to singly-quoted syntactic types, and given an operator \verb|⌜_⌝| which adds an extra level of quotation, we can define the type of a \emph{quine at φ} to be a (syntactic) type "Quine φ" which is isomorphic to "φ (⌜Quine φ ⌝))".
  - What's wrong is that self-reference with truth is impossible.  In a particular technical sense, it doesn't terminate.  Solution: Provability
  - Quining / self-referential provability sentence and provability implies truth
  - Curry--Howard, quines, abstract syntax trees (This is an interpreter!)

\appendix
\input{common.tex}
\input{prisoners-dilemma-lob.tex}
\input{lob-appendix.tex}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

%\printbibliography
\bibliographystyle{abbrvnat}
\bibliography{lob}


 \end{document}
